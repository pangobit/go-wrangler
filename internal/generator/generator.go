// Package generator generates validation and binding code for the given input
package generator

import (
	"fmt"
	"strings"

	"github.com/pangobit/go-wrangler/internal/parse"
)

// GenerateBindFunction generates Go code for a bind function that takes an http.Request and path params,
// binds them to the struct fields according to the bind tags.
func GenerateBindFunction(structInfo parse.StructInfo) (string, []string) {
	var sb strings.Builder

	sb.WriteString("// Code generated by go-wrangler. DO NOT EDIT.\n\n")

	needsStrconv := false
	for _, tag := range structInfo.Tags {
		if tag.Bind != nil && tag.FieldType == "int" {
			needsStrconv = true
		}
	}

	imports := []string{"fmt", "net/http"}
	if needsStrconv {
		imports = append(imports, "strconv")
	}

	// Function signature
	sb.WriteString(fmt.Sprintf("func Bind%s(r *http.Request, s *%s) error {\n", structInfo.Name, structInfo.Name))

	// Bind logic
	for _, tag := range structInfo.Tags {
		if tag.Bind != nil {
			var valueExpr string
			switch tag.Bind.Type {
			case "query":
				valueExpr = fmt.Sprintf("r.URL.Query().Get(\"%s\")", tag.FieldName)
			case "header":
				valueExpr = fmt.Sprintf("r.Header.Get(\"%s\")", tag.FieldName)
			case "path":
				valueExpr = fmt.Sprintf("r.PathValue(\"%s\")", tag.FieldName)
			}
			if tag.FieldType == "int" {
				sb.WriteString(fmt.Sprintf("\tif val, err := strconv.Atoi(%s); err != nil {\n\t\treturn fmt.Errorf(\"%s must be a valid integer\")\n\t} else {\n\t\ts.%s = val\n\t}\n", valueExpr, tag.FieldName, tag.FieldName))
			} else {
				sb.WriteString(fmt.Sprintf("\ts.%s = %s\n", tag.FieldName, valueExpr))
			}
			if tag.Bind.Required {
				if tag.FieldType == "int" {
					sb.WriteString(fmt.Sprintf("\tif s.%s == 0 {\n\t\treturn fmt.Errorf(\"%s is required\")\n\t}\n", tag.FieldName, tag.FieldName))
				} else {
					sb.WriteString(fmt.Sprintf("\tif s.%s == \"\" {\n\t\treturn fmt.Errorf(\"%s is required\")\n\t}\n", tag.FieldName, tag.FieldName))
				}
			}
		}
	}

	sb.WriteString("\treturn nil\n}\n")

	return sb.String(), imports
}

// GenerateValidateFunction generates Go code for a validate function that validates the struct fields according to the validate tags.
func GenerateValidateFunction(structInfo parse.StructInfo) (string, []string) {
	var sb strings.Builder

	sb.WriteString("// Code generated by go-wrangler. DO NOT EDIT.\n\n")

	// Check if strconv is needed
	needsStrconv := false
	for _, tag := range structInfo.Tags {
		if tag.Validate != nil && tag.FieldType != "int" {
			needsStrconv = true
		}
	}

	imports := []string{"fmt"}
	if needsStrconv {
		imports = append(imports, "strconv")
	}

	// Function signature
	sb.WriteString(fmt.Sprintf("func Validate%s(s *%s) error {\n", structInfo.Name, structInfo.Name))

	// Validation logic
	for _, tag := range structInfo.Tags {
		if tag.Validate != nil {
			if tag.FieldType == "int" {
				if tag.Validate.Min != nil {
					sb.WriteString(fmt.Sprintf("\tif s.%s < %d {\n\t\treturn fmt.Errorf(\"%s must be at least %d\")\n\t}\n", tag.FieldName, *tag.Validate.Min, tag.FieldName, *tag.Validate.Min))
				}
				if tag.Validate.Max != nil {
					sb.WriteString(fmt.Sprintf("\tif s.%s > %d {\n\t\treturn fmt.Errorf(\"%s must be at most %d\")\n\t}\n", tag.FieldName, *tag.Validate.Max, tag.FieldName, *tag.Validate.Max))
				}
			} else {
				// For non-int, parse and check
				if tag.Validate.Min != nil {
					sb.WriteString(fmt.Sprintf("\tif val, err := strconv.Atoi(s.%s); err != nil {\n\t\treturn fmt.Errorf(\"%s must be a valid integer\")\n\t} else if val < %d {\n\t\treturn fmt.Errorf(\"%s must be at least %d\")\n\t}\n", tag.FieldName, tag.FieldName, *tag.Validate.Min, tag.FieldName, *tag.Validate.Min))
				}
				if tag.Validate.Max != nil {
					sb.WriteString(fmt.Sprintf("\tif val, err := strconv.Atoi(s.%s); err != nil {\n\t\treturn fmt.Errorf(\"%s must be a valid integer\")\n\t} else if val > %d {\n\t\treturn fmt.Errorf(\"%s must be at most %d\")\n\t}\n", tag.FieldName, tag.FieldName, *tag.Validate.Max, tag.FieldName, *tag.Validate.Max))
				}
			}
		}
	}

	sb.WriteString("\treturn nil\n}\n")

	return sb.String(), imports
}

// GeneratePackage generates Go code for bind and validate functions for multiple structs
func GeneratePackage(structs []parse.StructInfo, pkgName string) string {
	var sb strings.Builder
	sb.WriteString("package " + pkgName + "\n\n")

	importSet := make(map[string]bool)
	var functions []string

	for _, s := range structs {
		bindCode, bindImports := GenerateBindFunction(s)
		functions = append(functions, bindCode)
		for _, imp := range bindImports {
			importSet[imp] = true
		}

		validateCode, validateImports := GenerateValidateFunction(s)
		functions = append(functions, validateCode)
		for _, imp := range validateImports {
			importSet[imp] = true
		}
	}

	if len(importSet) > 0 {
		sb.WriteString("import (\n")
		for imp := range importSet {
			sb.WriteString("\t\"" + imp + "\"\n")
		}
		sb.WriteString(")\n\n")
	}

	for _, fn := range functions {
		sb.WriteString(fn)
		sb.WriteString("\n")
	}

	return sb.String()
}
